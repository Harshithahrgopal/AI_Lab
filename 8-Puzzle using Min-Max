import copy

# --- GOAL STATE ---
goal_state = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]  # 0 = blank
]

# --- HELPERS ---
def print_board(state):
    for row in state:
        print(' '.join(str(x) if x != 0 else '_' for x in row))
    print()

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def move_blank(state, direction):
    x, y = find_blank(state)
    new_state = copy.deepcopy(state)
    if direction == "Up" and x > 0:
        new_state[x][y], new_state[x-1][y] = new_state[x-1][y], new_state[x][y]
    elif direction == "Down" and x < 2:
        new_state[x][y], new_state[x+1][y] = new_state[x+1][y], new_state[x][y]
    elif direction == "Left" and y > 0:
        new_state[x][y], new_state[x][y-1] = new_state[x][y-1], new_state[x][y]
    elif direction == "Right" and y < 2:
        new_state[x][y], new_state[x][y+1] = new_state[x][y+1], new_state[x][y]
    else:
        return None
    return new_state

def get_successors(state):
    moves = ["Up", "Down", "Left", "Right"]
    successors = []
    for m in moves:
        new_state = move_blank(state, m)
        if new_state:
            successors.append((m, new_state))
    return successors

# --- HEURISTIC FUNCTION ---
def heuristic(state):
    """Simple: number of misplaced tiles."""
    h = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0 and state[i][j] != goal_state[i][j]:
                h += 1
    return h

# --- MINIMAX SEARCH ---
def minimax(state, depth, maximizing):
    if state == goal_state or depth == 0:
        return -heuristic(state)

    if maximizing:
        max_eval = float('-inf')
        for move, succ in get_successors(state):
            val = minimax(succ, depth - 1, False)
            max_eval = max(max_eval, val)
        return max_eval
    else:
        min_eval = float('inf')
        for move, succ in get_successors(state):
            val = minimax(succ, depth - 1, True)
            min_eval = min(min_eval, val)
        return min_eval

# --- FIND BEST MOVE ---
def best_move(state, depth=3):
    best_val = float('-inf')
    best_state = None
    best_move_name = None

    for move, succ in get_successors(state):
        val = minimax(succ, depth - 1, False)
        if val > best_val:
            best_val = val
            best_state = succ
            best_move_name = move

    return best_move_name, best_state

# --- MAIN FUNCTION ---
def play_puzzle(state, depth=3):
    print("Initial State:")
    print_board(state)

    move, new_state = best_move(state, depth)
    if move:
        print(f"Move: {move}")
        print_board(new_state)
    else:
        print("No move found or already solved!")

# --- TEST ---
start_state = [
    [1, 2, 3],
    [4, 0, 6],
    [7, 5, 8]
]

play_puzzle(start_state, depth=3)
