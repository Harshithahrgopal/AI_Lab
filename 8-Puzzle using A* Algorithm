import heapq

class PuzzleState:
    """Represents a state in the 8-puzzle problem."""
    def __init__(self, board, parent=None, move=None, g_cost=0):
        self.board = board  # The 3x3 puzzle board (tuple of tuples for immutability)
        self.parent = parent  # Parent state for path reconstruction
        self.move = move  # The move that led to this state
        self.g_cost = g_cost  # Cost from start to this state

    def __lt__(self, other):
        """Comparison for priority queue based on f-cost (g + h)."""
        return (self.g_cost + self.heuristic()) < (other.g_cost + other.heuristic())

    def __eq__(self, other):
        """Equality check for comparing states."""
        return self.board == other.board

    def __hash__(self):
        """Hashing for set operations."""
        return hash(self.board)

    def heuristic(self):
        """Calculates Manhattan distance heuristic."""
        h = 0
        for r in range(3):
            for c in range(3):
                tile = self.board[r][c]
                if tile != 0:
                    # Calculate target row and column for the tile
                    target_r, target_c = divmod(tile - 1, 3)
                    h += abs(r - target_r) + abs(c - target_c)
        return h

    def get_blank_position(self):
        """Finds the (row, col) of the blank space (0)."""
        for r in range(3):
            for c in range(3):
                if self.board[r][c] == 0:
                    return r, c

    def generate_neighbors(self):
        """Generates valid neighboring states."""
        neighbors = []
        blank_r, blank_c = self.get_blank_position()

        moves = [(0, 1, "Right"), (0, -1, "Left"), (1, 0, "Down"), (-1, 0, "Up")]

        for dr, dc, move_name in moves:
            new_r, new_c = blank_r + dr, blank_c + dc

            if 0 <= new_r < 3 and 0 <= new_c < 3:
                new_board_list = [list(row) for row in self.board]
                new_board_list[blank_r][blank_c], new_board_list[new_r][new_c] = \
                    new_board_list[new_r][new_c], new_board_list[blank_r][blank_c]
                new_board = tuple(tuple(row) for row in new_board_list)
                neighbors.append(PuzzleState(new_board, self, move_name, self.g_cost + 1))
        return neighbors

def print_puzzle(board):
    """Prints the puzzle board in a readable format."""
    for row in board:
        print(" ".join(map(str, row)))

def solve_8_puzzle_a_star(initial_board):
    """Solves the 8-puzzle problem using A* algorithm."""
    goal_board = ((1, 2, 3), (4, 5, 6), (7, 8, 0))
    start_state = PuzzleState(initial_board)

    open_set = [start_state]  # Priority queue for states to explore
    closed_set = set()       # Set to store visited states

    print("Initial State:")
    print_puzzle(start_state.board)
    print("--------------------")

    while open_set:
        current_state = heapq.heappop(open_set)

        if current_state.board == goal_board:
            path = []
            while current_state:
                path.append(current_state)
                current_state = current_state.parent
            path.reverse()

            print("\nGoal Reached! Solution Path:")
            for i, state in enumerate(path):
                print(f"Step {i}: Move {state.move if state.move else 'Start'}")
                print_puzzle(state.board)
                print("--------------------")
            return

        closed_set.add(current_state)

        for neighbor in current_state.generate_neighbors():
            if neighbor in closed_set:
                continue

            # Check if neighbor is already in open_set with a higher g_cost
            in_open_set = False
            for i, item in enumerate(open_set):
                if item == neighbor and item.g_cost > neighbor.g_cost:
                    open_set[i] = neighbor # Update with lower g_cost
                    heapq.heapify(open_set)
                    in_open_set = True
                    break
                elif item == neighbor:
                    in_open_set = True
                    break

            if not in_open_set:
                heapq.heappush(open_set, neighbor)

    print("No solution found.")

# Example Usage:
# Define the initial board state (0 represents the blank tile)
initial_puzzle = (
    (1, 2, 3),
    (0, 4, 6),
    (7, 5, 8)
)

solve_8_puzzle_a_star(initial_puzzle)
